# 浏览器进程
* 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
* 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
* GPU进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
* 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

# 从输入URL到页面展示，这中间发生了什么
## 解析用户输入
* 输入的是关键字，则浏览器使用默认的搜索引擎生成搜索该关键字的URL
* 输入的是URL，则直接使用该URL  
* 浏览器把URL传递给网络进程

## URL请求过程  
首先从缓存中查找该页面是否有缓存，如有则直接取缓存页面返回给浏览器进程，没有则走请求流程。  
#### 与服务器建立链接需要服务器IP地址和端口号  
浏览器进程把任务移交到网络进程，网络进程负责网络传输功能。
* IP地址的获取：需要去DNS服务器查询域名对应的IP地址，如果DNS缓存中有，则取缓存，没有则向DNS服务器获取，拿到IP后再在DNS缓存中记录。  
* 端口号获取：如果URL中定义了端口号，直接使用。如果没有，http使用默认的80端口，https使用默认的443端口。
* 与服务器建立TCP/IP连接（如果协议是https请求，还需要先进行TLS连接；同时能进行6个TCP连接，需要排队），建立成功后，内容用http协议头封装（构建请求行、请求头、请求体），再用tcp协议封装，发送到服务器。
* 服务器回复后，解析http头部，根据状态码、content-type做一些决策，如状态码301、302，则需要根据location字段再进行请求；
如content-type为html/text或者application/octet-stream来区分内容体需要什么形式来处理。
* 浏览器进程发出“提交文档”的消息，渲染进程收到后，会与网络进程建立管道，用于传输数据。传输完成后，渲染进程发出“确认提交”消息
给浏览器进程，这时候浏览器更新标签中的icon状态、前进后退状态、URL地址栏、web页面。
* 通常情况下，每一个标签都会配一个渲染进程处理，但如果是同一站点（相同的协议和根域名），则使用同一个渲染进程（配了noopener noreferrer除外）。

## 渲染流程
### 渲染进程处理流程
#### 构建DOM树
解析html的元素，构建一颗父子树，这棵树显示了父子节点的关系和属性。
#### 构建CSS树
解析link内CCS、style内CSS、元素内联CSS，为DOM树的节点计算出浏览器可识别的属性，继承、层叠的样式。
#### 布局树（layout）
将不显示的节点去掉（html、head、link、display: none的节点）。计算出可见元素的的坐标位置和大小。
#### 图层（layer）
计算出特定节点的图层位置，可以理解为垂直于页面的z轴位置，需要裁剪的地方、明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
没有的话就是用父元素的图层，
最后显示是按照这些z轴位置从上至下显示出来。
#### 图层绘制（paint）
把一个图层的绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表，交给合成子线程处理显示任务。
### 合成子线程处理流程
* 把图层划分为一块块小的图块，视口优先处理，然后图块生成位图（栅格化）。
* 通常会使用GPU加速栅格化，则把栅格化任务交给GPU处理，GPU处理完后，把位图存在GPU内存中，发出一个处理完成的指令。
* 渲染进程收到指令后将内容绘制在在内存中，最后显示到屏幕上。

